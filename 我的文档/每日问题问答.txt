JAVA基础：


JAVA多线程和并发:

1.JAVA的锁机制?/JAVA怎实现线程安全?
 -2.什么是线程安全？为什么会有线程安全问题?   提出问题
 -3.怎么解决线程安全问题?                     解决问题
       -synchonrized 优点和缺点引出他的应用范围
       -Atomic       优点和缺点
       -Lock
       总结：你的建议应该如何选择
 -4.更细程度的说明锁机制的原理?
 -5.之前我们学习过的部分哪些东西有用到或者借鉴了这些机制？他们有什么异同？
 	数据库行级锁和表级锁
 	ConcurrentHashMap的锁分离
 	数据库事务
 	Servlet的请求：多线程（每一次请求都是一个线程有可能产生线程安全问题）
 -6.一些额外的注意点？


 回答：
 #什么是线程安全?
 	多个线程同时访问同一个资源(临界区)就有可能产生线程安全问题.
 #怎么解决线程安全问题?
 	一个程序一段代码是线程安全的需要满足一下三种特性:原子性，有序性和可见性
 	Java使用锁机制来解决线程安全问题，常见的有三种解决方式
 	1.synchonrized 是一种互斥锁，悲观锁和非公平锁;他有粗粒度(对整个方法加锁)和细粒度(对方法中的某一部分加锁)。保证了原子性和有序性
 	优点：最简单，JDK的内置模式，安全级别最高也是最先考虑的方式
 	缺点：性能最低，不恰当使用很容易产生死锁问题
 	2.Atomic原子变量 保证了原子性
 	优点：实现简单
 	缺点：他一般用于加减等数值操作的部分，局限性比较大
 	3.Lock 显示锁() 用法基本跟synchonrized一样，只是你可以自己定制锁的类别
 	优点：自己定制 需要你对锁机制的有比较深的理解。可以实现乐观锁和公平锁
 	缺点：自己定制 需要你对锁机制的有比较深的理解。

 	总结：优点使用synchonrized 当他无法满足我们的需求的时候再考虑其他的方式。注意死锁。
#锁机制的原理？
	互斥锁：资源只能被同一个线程访问
	悲观锁：资源不能被抢占
	乐观锁：可以通过一定的规则抢占资源
	公平锁：我们可以规定一些规则来决定资源的抢占。(计数器来做 每一次请求都会让你的请求计数+1，当达到指定数量后你就获得了资源的占有权)
	非公平锁：只要我请求资源，就一定是我的。
#之前我们学习过的部分哪些东西有用到或者借鉴了这些机制？他们有什么异同？
	数据库行级锁和表级锁
	ConcurrentHashMap的锁分离
	数据库事务
	Servlet的请求：多线程（每一次请求都是一个线程有可能产生线程安全问题）
#其他注意事项
	多线程产生死锁的四个必要条件： 

   	#互斥条件：一个资源每次只能被一个进程使用。
    #保持和请求条件：一个进程因请求资源而阻塞时，对已获得资源保持不放。
    #不可剥夺调教：进程已获得资源，在未使用完成前，不能被剥夺。
    #循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

  	只要破坏其中任意一个条件，就可以避免死锁，其中最简单的就是破环循环等待条件。按同一顺序访问对象，加载锁，释放锁。其中最简单的方法就是线程都是以同样的顺序加锁和释放锁，也就是破坏了第四个条件。