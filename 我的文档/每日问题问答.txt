#集合
1.HashMap是有序的吗？  无序
2.有没有序的Map?         TreeMap 和 LinkedHashMap
3.TreeMap和LinkedHashMap怎么保证它的顺序？
	TreeMap的实现是红黑树算法的实现，只要你存入的二叉树有序 你的Map就是有序的。
	LinkedHashMap,它保留插入的顺序，每一个Entry记录他的上一个和下一个节点
4.你觉得哪一种排序的方式更好?
	TreeMap是红黑树(平衡的二叉树),是排序好的Entry，如果你需要排序就是用它
	LinkedHashMap只保证顺序，不排序(排序是需要消耗性能的)
Entry(Key，Value)一个键值对 就是一个Entry

#
1.HashMap是线程安全的吗?不是
2.有没有线程安全的键值对?	 hashTable和ConcurrentHashMap
3.分别怎么实现线程安全？
  HashTabel靠synchronized来实现线程安全
  ConcurrentHashMap锁分离机制，是并发包里面的内容。
4.你觉得哪一种比较好?
	一般来讲ConcurrentHashMap会更好，锁分离机制保证一定并发量。
	HashTabel对整个集合加锁，安全性更高，性能很低。
	
JAVA基础：


1.什么是同步？什么是异步?




JAVA多线程和并发:

1.单核单任务(你的电脑只能同时干一件事情  只能同时运行一个进程)
2.单核多任务(你的电脑能同时干多件事情  能同时运行多个进程 进程调度)
3.多核多任务
4.多核多线程(利用多核CPU的性能,你开的线程数量跟你的CPU核心数一样)
因为利用多核CPU的性能才会有多线程

1.JAVA的锁机制?/JAVA怎实现线程安全?
 -2.什么是线程安全？为什么会有线程安全问题?   提出问题
 -3.怎么解决线程安全问题?                     解决问题
       -synchonrized 优点和缺点引出他的应用范围
       -Atomic       优点和缺点
       -Lock
       总结：你的建议应该如何选择
 -4.更细程度的说明锁机制的原理?
 -5.之前我们学习过的部分哪些东西有用到或者借鉴了这些机制？他们有什么异同？
 	数据库行级锁和表级锁
 	ConcurrentHashMap的锁分离
 	数据库事务
 	Servlet的请求：多线程（每一次请求都是一个线程有可能产生线程安全问题）
 -6.一些额外的注意点？


 回答：
 #什么是线程安全?
 	多个线程同时访问同一个资源(临界区)就有可能产生线程安全问题.
 #怎么解决线程安全问题?
 	一个程序一段代码是线程安全的需要满足一下三种特性:原子性，有序性和可见性volatile
 	Java使用锁机制来解决线程安全问题，常见的有三种解决方式
 	1.synchonrized 是一种互斥锁，悲观锁和非公平锁;他有粗粒度(对整个方法加锁)和细粒度(对方法中的某一部分加锁)。保证了原子性和有序性
 	优点：最简单，JDK的内置模式，安全级别最高也是最先考虑的方式
 	缺点：性能最低，不恰当使用很容易产生死锁问题
 	2.Atomic原子变量 保证了原子性
 	优点：实现简单
 	缺点：他一般用于加减等数值操作的部分，局限性比较大
 	3.Lock 显示锁() 用法基本跟synchonrized一样，只是你可以自己定制锁的类别
 	优点：自己定制 需要你对锁机制的有比较深的理解。可以实现乐观锁和公平锁
 	缺点：自己定制 需要你对锁机制的有比较深的理解。

 	总结：优点使用synchonrized 当他无法满足我们的需求的时候再考虑其他的方式。注意死锁。
#锁机制的原理？
	互斥锁：资源只能被同一个线程访问
	悲观锁：资源不能被抢占
	乐观锁：可以通过一定的规则抢占资源
	公平锁：我们可以规定一些规则来决定资源的抢占。(计数器来做 每一次请求都会让你的请求计数+1，当达到指定数量后你就获得了资源的占有权)
	非公平锁：只要我请求资源，就一定是我的。
#之前我们学习过的部分哪些东西有用到或者借鉴了这些机制？他们有什么异同？
	数据库行级锁和表级锁
	ConcurrentHashMap的锁分离
	数据库事务
	Servlet的请求：多线程（每一次请求都是一个线程有可能产生线程安全问题）
	为什么String是final类型的(key值不可变)
#其他注意事项
	多线程产生死锁的四个必要条件： (前三个就是synchonrized的特点)
   	#互斥条件：一个资源每次只能被一个进程使用。
    #保持和请求条件：一个进程因请求资源而阻塞时，对已获得资源保持不放。
    #不可剥夺调教：进程已获得资源，在未使用完成前，不能被剥夺。
    #循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

  	只要破坏其中任意一个条件，就可以避免死锁，其中最简单的就是破环循环等待条件。按同一顺序访问对象，加载锁，释放锁。其中最简单的方法就是线程都是以同样的顺序加锁和释放锁，也就是破坏了第四个条件。

2.sleep和wait - wait和notify的区别
	这些都是线程的方法。wait释放锁，notify获得锁，sleep不会释放锁。

网络编程：

0.网络架构一共有几层?  OSGI模型
	1物理层
	2数字链路层
	#3网路层 - IP协议(标识你的计算机在网络中的位置，计算机通过IP地址找到另外一台计算机)
	#4传输层 - TCP协议(代表你有进行网络传输的功能)
	5会话层
	6表示层  - 加密解密 ，压缩和解压缩
	#7应用层 - (我们开发的WEB应用都是属于这一行) HTTP协议(你传输的是什么数据类型)

1.什么是TCP/IP协议?
	是协议簇(是一套协议的总结,TCP和IP协议最具有代表性)

	IP协议(标识你的计算机在网络中的位置，计算机通过IP地址找到另外一台计算机)
	TCP协议(代表你有进行网络传输的功能)
		面向连接(发数据之前要先确认连接的正确性)
		相当于打电话，需要先拨通再通话
	UDP协议(报文协议)
		面向无连接(发数据不需要任何准备，只管发)
		相当于短信，发出去之后无法知道对方到底有没有接收到。

	#TCP怎么保证连接的正确性
	TCP的三次握手：
		*  //什么是三次握手 syn包(请求包) ack包(确认包)
		*  //1.客户端向服务端发送请求syn包
		*  //2.服务端收到syn包，向客户端发送syn+ack包，服务端建立连接(可以接受数据了)
	 	*  //3.客户端收到syn+ack包,向服务端发送ack包， 客户端建立连接(可以接受数据了)

	#HTTP协议
	HTTP协议是TCP协议的一种，超文本传输协议。http是对TCP协议的扩展(本质上也是个TCP协议)
	TCP决定你可以进行传输,HTTP决定了你传输的数据类型
	为什么http协议很流行? 1.简单易用  2.很容易进行扩展 MIME（传输的文件类型编号，看tomcat的web.xml）

	请求只能由客户端发起，无法保持连接（下一次请求无法知道上一次请求的内容）
	keep-alive：HTTP1.1的内容，能保持一小段时间的连接(避免重复刷新等)

	请求头：
		Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8  （接收的文本类型）
		Accept-Encoding:gzip, deflate, sdch, br   （压缩算法）
		Accept-Language:zh-CN,zh;q=0.8,en;q=0.6,ja;q=0.4,zh-TW;q=0.2 （接收的语言）
		Cache-Control:no-cache   （缓存控制）
		Connection:keep-alive     （连接状态）
		Cookie:BAIDUID=6C2F642C3700496ED788B9E08154D874:FG=1; BIDUPSID=6C2F642C3700496ED788B9E08154D874; PSTM=1490253481; ispeed_lsm=2; BD_CK_SAM=1; PSINO=6; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; BD_HOME=0; H_PS_PSSID=22162_1459_21098_21671_22581; BD_UPN=12314353 （cookie编号）
		Host:www.baidu.com   （主机名称）
		Pragma:no-cache      （缓存控制）
		User-Agent:Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36  （浏览器类型）
	响应头：

	#HTTP和HTTPS有什么区别？  security安全
		公钥和秘钥，网络证书来保证连接的安全性
		HTTP是明文连接，连接可以被劫持()
	#get和Post方法的区别?

2.什么是Socket?
	如果没有Socket，每次网络连接我都要处理七层的传输和协调。而且这些都是通用的方法
	所以我们就封装了一套API来统一处理 就是SOCKET。
	Socket是一套API，不是网络协议。来简化网络传输的编程。
	Socket是对网络各层的抽象，简化了网络传输的步骤。

JAVAEE三大框架：

//1.什么是IOC
//2.如何实现IOC
//3.IOC有什么作用

1.讲一下你对JAVAEE三大框架的理解?
	第一步(拆分问题 大的问题拆分成小的问题)
	#概念的描述：什么是三大框架？
	SSH(SpringStruts2Hibernate):
	SSM(SpringSpringMvcMybatis):
	//SSH2(SpringSpringMvcHibernate)
	类比MVC模式 Spring相当于:
	Controller控制层，  由它来负责管理其他两个框架
				Struts和Springmvc都是View显示层，参数传递和页面跳转
				Hibernate和Mybatis是ORM框架Model实体层，负责数据库和java对象之间的映射

	非侵入式，解耦合，轻量级的开源JAVA开发应用框架，其目的是用于简化JAVAEE企业级应用程序开发
	#Spring框架
		IOC/DI：
		    #什么是控制反转？ 
			IOC(InverseOfController控制的反转): 
			-谁控制谁 ，控制什么 ：传统 Java SE 程序设计，我们直接在对象内部通过 new 进行创建对象，是程序主动去创建依赖对象；而 IoC 是有专门一个容器来创建这些对象，即由 Ioc 容器来控制对象的创建；谁控制谁？当然是 IoC 容器控制了对象；控制什
			么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。

			-为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对
			象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及
			注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被
			动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了

			我们不再创建手动new我们的Bean对象，交给我们的Bean工厂或者叫Spring容器(ApplicationContext 读取你的spring配置文件来生成)

			#在Spring里面怎么使用IOC？
			首先需要在容器里面注册它（由你编写的java对象转化为spring的bean对象）
			1.注解的方式(注解扫描)
				IOC注解 (相当于在容器里面注册这个对象) 放置在类上面
				开启注解扫描<context:component-scan base-package="com.ssf.*"/>

				@Component   model层
				@Repository  dao层
				@Service     service层
				@Controller  web层
				这四个注解逻辑上完全一致(在容器里面注册这个对象)，只是为了被封装的对象属于哪一层

			2.XML的方式
			<bean id="proxy" class="com.ssf.proxy.AOPProxy"></bean>

            #为什么我们要使用它？
            	IOC是Spring框架的基础为了进行统一管理，所有的对象必须先在容器里面注册

            #什么是依赖注入?
            DI(DependInject依赖注入):
            容器注入 Bean  的 依赖 资源 ：容器负责注入 Bean 的依赖资源，依赖资源可以是
			Bean、外部文件、常量数据等，在 Java 中都反映为对象，并且由容器负责组装
			Bean、外部文件、常量数据等，在ean 之间的依赖关系， 此处的依赖是指 Bean  之间的依赖关系， 可以认为是传统类与类之间的“关联”、“聚合”、“组合”关系。

            我们的Bean对象A需要依赖另外一个Bean对象B的方法，就需要把B依赖注入.

            #在Spring里面怎么使用DI？
            1.注解的方式
            	DI注解
            	首先A和B都需要先被注册，如果是接口你的IOC注解应该放在实现类上面
            	引入DI注解
            	@Autowired  Spring的注解，按类型注入
            	@Resource   JDK的注解，   按名称注入(默认名称是 类名的首字母小写)

            2.XML的方式
               <bean id="A" class="com.ssf.proxy.A">
					<property name="B" ref="B"/> <!-- 对象B的注入 -->
      				<property name="typeAliasesPackage" value="com.ssf.model"/> <!-- 属性的注入 -->

      				<constructor-ref>
               </bean>
               <bean id="B" class="com.ssf.proxy.B"></bean>

            依赖注入的方式：
            	setter注入：需要由setter和getter方法（默认都是setter的方式）
            	构造器注入：需要改写构造方法（强制要求）
            #依赖注入的优点：
            	动态替换Bean依赖对象， 程序更灵活
            	更好实践面向接口编程 ，代码更清晰
            总结：Spring容器生成Bean对象singleton单例模式（节省内存的消耗），lazy_init 延迟加载（节省内存的消耗，很多对象我只在需要的时候才生成它,因为一开始大量的对象是还没使用到的不需要一开始就创建出来）

		AOP：跟第三方组件的解耦合
			AOP(AspectOrientProgramming面对切面编程)
			我们的java程序时是线性执行的，AOP提供了另外一种横向切入功能。
			# 在哪里切入，切入的方法是什么 (切入到某一个方法里面)
			- JointPoint连接点:   AOP跟我们JAVA程序交接的地方
			- PointCut切入点： 在哪里切入(方法的集合)
			- Advice通知（增强方法）：切入的方法是什么(你要增强的功能)
			- Aspect切面: 相当于切入点+增强方法 ，可以有多个切面

			框架是怎么实现AOP功能
			动态代理 JDK(代理接口)和CGLib动态代理(接口和非接口都能代理)

		事务处理：
		   Spring的事务就是靠AOP来实现的
		   一般是在Service层来处理事务
		   根据切入点来过滤方法，引入增强方法（事务）
		   事务的传播机制 reqiured
		   数据库事务的定义

	    <aop:config>
	        <aop:pointcut
	           expression="execution(* com.ssf.service.impl.*.*(..))"
	           id="txpointcut"/>
	        <aop:advisor advice-ref="txadvice" pointcut-ref="txpointcut"/>
	    </aop:config>

	#Struts2和SpringMVC的区别:

	//不使用框架 servlet+jsp
	1.获取参数 - String username = req.getPameter("username")
	2.参数验证
	3.业务方法
	4.异常处理
	5.逻辑处理-成功
              -失败
    6.在web.xml注册 url指定到类那一级别 

    //Struts2
    1.简化获取参数 -   username;
    2.简化了页面跳转 - 
    3.url可以指定方法那一级别
    缺点：
    团队太久没人维护
    13-14爆出安全漏洞，官方直接把漏洞公布出来

    //SpringMVC的作用
    1.进一步简化请求参数封装User    public String login(User user,Model model)
    2.简化了页面跳转
    3.url可以指定到方法那一级别
    4.RESTFUL风格  user/list/1  用url来传参
    5.非常容易整合JSON等数据处理，有利于手机端的数据操作
    6.天然跟Spring整合(本身就是spring的一个模块)
    7.使用注解配置的方式能极大简化配置(约定大于配置#你只需要修改你要改变的部分 提供默认配置)

    #ORM框架   #JPA#
    	什么是ORM？什么是持久(Persist)层?
    	Hibernate和Mybatis的区别？（封装的越多性能越低）  数据库最重要的是性能和安全

    	Mybatis是一种轻量级别的ORM，只提供了基础的ORM，具体的SQL还是需要编程人员来实现()
    	提供了一种generagor来生成基础的sql语句
    	Hibernate是更完善的封装，很多基础的sql不需要编写。可以更快进行业务代码处理。


	#额外知识：
		1.Bean工厂，Spring容器，SpringContextSpring上下文: 	ApplicationContext 继承了 BeanFactory
		2.Bean对象 是对你的编写的java对象进行了一层封装（在容器里面注册它）
		3.注解方式和XML配置方式有什么区别?

2.什么是SpringMVC
	//#SpringMVC的概念
	Spring Web MVC是一种基于Java的实现了WebMVC设计模式的请求驱动类型的轻量级Web框架，即使用了MVC架构模式的思想，将web层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发，Spring Web MVC也是要简化我们日常Web开发的。
	//#SpringMVC的作用
    1.进一步简化请求参数封装User    public String login(User user,Model model)
    2.简化了页面跳转
    3.url可以指定到方法那一级别
    4.RESTFUL风格  user/list/1  用url来传参
    5.非常容易整合JSON等数据处理，有利于手机端的数据操作
    6.天然跟Spring整合(本身就是spring的一个模块)
    7.使用注解配置的方式能极大简化配置(约定大于配置#你只需要修改你要改变的部分 提供默认配置)
    //#我们怎么使用它

Java虚拟机与GC：

1.JAVA里面谁来负责对象的销毁?
	
1.什么是对象的生命周期
	init
	service
	destory

1.Java的内存模型?JMM
	栈Stack:
		引用,基本类型 （效率最高）
	堆Heap:最大的一块
		你们new出来的对象就都在这里
	静态方法区（编译时）
		静态属性，方法体，常量池
	本地方法栈
	    JNI(用java执行其他语言)
	String str = new String("ssss");
	//1.str引用
	//2."ssss" 常量池(位于静态方法区)
	//3.堆里面(调用new关键字的对象都是在堆里面)

	String str2 = "ssss";

2.什么是GC?GC有什么作用？
    #GC的概念
	GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显示的垃圾回收调用。
	#GC的用处
	垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在Java诞生初期，垃圾回收是Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今Java的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得iOS的系统比Android系统有更好的用户体验，其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。
	#GC的机制 
	补充：垃圾回收机制有很多种，包括：分代复制垃圾回收、标记垃圾回收、增量垃圾回收等方式。标准的Java进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建的对象。Java平台对堆内存回收和再利用的基本算法被称为标记和清除，但是Java对其进行了改进，采用“分代式垃圾收集”。这种方法会跟Java对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域：
	- 伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。
	- 幸存者乐园（Survivor）新生代：从伊甸园幸存下来的对象会被挪到这里。
	- 终身颐养园（Tenured） 老年代：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。

	#GC的具体执行
		java GC是在什么时候，对什么东西，做了什么事情
2.你能不能谈谈，java GC是在什么时候，对什么东西，做了什么事情？”
	#什么时候
	总结：程序员不能具体控制时间，系统在不可预测的时间调用System.gc()函数的时候；当然可以通过调优，用NewRatio控制newObject和oldObject的比例，用MaxTenuringThreshold 控制进入oldObject的次数，使得oldObject 存储空间延迟达到full gc,从而使得计时器引发gc时间延迟OOM的时间延迟，以延长对象生存期。

	#对什么东西
	总结：超出了作用域或引用计数为空的对象；
	从gc root开始搜索找不到的对象，而且经过一次标记、清理，仍然没有复活的对象。

	#做了什么事情
	总结：删除不使用的对象，回收内存空间；运行默认的finalize,当然程序员想立刻调用就用dipose调用以释放资源如文件句柄，JVM用from survivor、to survivor对它进行标记清理，对象序列化后也可以使它复活

	#新生代 老年代

3.JAVA会有内存泄漏吗?为什么
    严格来说并不能算内存泄漏。跟C不一样 因为你没有释放申请的内存空间。
	程序有无用但"可达"的对象,不会被GC收集。

4.OOM(OutOfMeomry内存溢出)  SOF(StackOverFlow栈溢出)
	OOM(OutOfMeomry内存溢出) 死循环new对象
	SOF(StackOverFlow栈溢出) 递归不收敛(死循环调用方法)


异常处理：

0.讲一讲JAVA的异常机制?
	#异常的API，体系
		所有的异常都继承自Throwable,Error和Exception有什么区别
		Error：讲讲OOM(OutOfMemoryError:死循环创建对象new)
				  和SOF(StackOwerFlowError):死循环调用方法 不收敛的递归
	    Exception： IOException
	   				 RuntimeException：#什么是运行时异常       逻辑性的错误
	    				运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引
	    			#常见5个运行时异常：
	    				- ArithmeticException（算术异常）
						- ClassCastException （类转换异常）
						- IllegalArgumentException （非法参数异常）
						- IndexOutOfBoundsException （下标越界异常）
						- NullPointerException （空指针异常）
						- SecurityException （安全异常）  
	#JAVA是怎么处理异常的


	try来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；

	try用来指定一块预防所有异常的程序；
	catch子句紧跟在try块后面，用来指定你想要捕获的异常的类型；
	throw语句用来明确地抛出一个异常；
	throws用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；
	finally为确保一段代码不管发生什么异常状况都要被执行；

	try语句可以嵌套，每当遇到一个try语句，异常的结构就会被放入异常栈中，直到所有的try语句都完成。如果下一级的try语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这种异常的try语句或者最终将异常抛给JVM。

		try:  try来执行一段程序,包裹可能产生异常的代码块
		catch: 可以通过它的类型来捕获（catch）它，明确指定异常的类型
		throw:  系统会抛出（throw）一个异常对象
		throws: throws用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）
		finally: finally为确保一段代码不管发生什么异常状况都要被执行

		try语句可以嵌套，每当遇到一个try语句，异常的结构就会被放入异常栈中，直到所有的try语句都完成。如果下一级的try语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这种异常的try语句或者最终将异常抛给JVM。

#final finally finalize有什么区别?
	final修饰符 代表不可变
	final修饰类 类不可被继承
	final修饰方法 方法不能被重写
	final修饰变量 变量不能被重新赋值

	finalize最后被垃圾收集前调用的方法


1。Error和Exception有什么区别？
答：Error表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。
Error和Exception都继承自Throwable

2.运行时异常和编译时异常的区别
3.有哪些运行时异常
4.Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？

5.什么时候用断言（assert）
	断言在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。一般来说，断言用于保证程序最基本、关键的正确性。断言检查通常在开发和测试时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。

	要在运行时启用断言，可以在启动JVM时使用-enableassertions或者-ea标记。要在运行时选择禁用断言，可以在启动JVM时使用-da或者-disableassertions标记。要在系统类中启用或禁用断言，可使用-esa或-dsa标记。还可以在包的基础上启用或者禁用断言。


WEB基础：

1.什么是MVC?什么是WEBMVC框架?
    #MVC的概念
    MVC是一种编程思想 设计模式.
	Model模型 实体或JavaBean
	View视图  JSP/html
	Controller控制 Servlet
	#MVC的作用
	逻辑和显示分离，后端和前端的分离。
    #怎么使用MVC
    1直接使用WEBMVC框架
    2将Servlet作为C JSP作为View JavaBean作为Model，以这种风格组织的代码就实现最简单的MVC。
    #扩展
    SSH或者SSM其实也是一种MVC的思想
    前端的JS/html/CSS也是一种MVC思想的体现

    WEBMVC框架是实现了MVC的一套web开发框架，简化了web开发流程，强制了开发流程(只要你使用了WebMvc框架，你就使用了MVC模式)

2.什么是Java语言,谈谈你对java的理解?
	编译型语言，语法的统一和固定化
	面向对象，跨平台，GC内存管理
	1.多态，继承，封装，抽象
	封装：JavaBean 私有化属性 公有化方法setter和getter
		  封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口
	继承：很多重复的属性作为父类 使用子类来继承它 这样子不会重复而且更好管理
		  继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。
		  例子：BaseDao

	多态：多态性是指允许不同子类型的对象对同一消息作出不同的响应。面向接口编程
	      List<T> t = new ArrayList<T>();
	      ArrayList<T> t = new ArrayList<T>();
	      多态性分为编译时的多态性和运行时的多态性

	      方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1). 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2). 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。
	抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。（从需求分析中抽象出对象类的过程）

	2.跨平台
		java虚拟机的运行过程
		1.java文件转化成class文件(编译期)
		2.class加载到虚拟机运行(运行时Runtime)
		代理模式：跟操作系统解耦，由虚拟机来处理不同操作系统之间的异同
	3.GC内存管理 # Java虚拟机
		理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收，因此也会导致内存泄露的发生。例如hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露
		#没有引用指向的堆内存 就会被回收（在集合里面存对象 你又修改集合的大小）

		JDK的方式#标记-清除模式： 
		object-c#引用计数模式：引用一次 计数+1 ， 每被释放一次计数-1

	Java的应用范围: 你为什么要学习Java，Java语言的应用范围
		#上手简单-精通难
		因为语言风格的统一和简化(适合新手) -> 第一个工程型语言，适合大规模协作(业界通用) -> 有很多成熟的商业项目和开源框架() -> 生态圈的确立

		跟硬件交互的部分相对欠缺(JNI调用c程序来处理)
		需求最大的语言 最好就业和入门。

3.什么是Java的类加载机制?ClassLoader-%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;%JAVA_HOME%\jre\lib\rt.jar;
	#类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。
		1Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；
		2Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；
		3System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。
	#双亲委托机制：PDM
		1.你的类的加载先交给父类加载器执行，如果父类加载不了再由子类加载器加载。
		2.已经加载过的类不会重新加载。

		#安全机制：如果你定义了一个 java.lang.String类 不会覆盖掉JDK的类
	#如果你需要自定义类加载器的话 你要怎么做?
		1.把父类加载器置为null
		2.让你的自定义加载器加载类

	#Tomcat的类加载器(自定义类加载器)
	    为什么你的jar包要放在WEB-INF/lib目录底下

4.初始化构造器的顺序
	1.初始化静态成员  编译时产生只会有一份
	2.调用父类的构造器
	3.初始化非静态成员
	4.调用自身的构造器

数据库部分：
1.介绍你工作中的数据库优化策略?

String相关模型:
	#
	String s = new String("ab");(Java内存模型)
	String s2 = "ab";
	String s3 = "a" + new String("b");

	#StringBuffer,StringBuild(不可变,内存模型，线程安全)
	#split切分需要符号。(正则表达式)
	#String是final? 为什么他是final？
	 因为他一般是作为键值对的key值，为了保证key值的不可变 hashMap(集合)
	#中文乱码 字符流 字节流 (IO流)
	#异常
	#hASHCODE的作用?
	#EQUALS 和 == 的区别  # Equals默认就是比较地址(==)


2.公司为什么要雇用你/
	1.你的价值来源于你的利用价值(有人指点可遇而不可求)

	2.沟通能力(跟人合作,有问题不跟你交流) 30-
	  技术能力() 20
	  朝气，个人气质(每天要有8个小时跟你一起过的) 20
	  学校和专业(本科本专业 专科本专业 本科非专业  专科非专业) 10
	  英语能力和数学能力 10
	  个人荣誉 10

	3.JAVA基础和开发框架和数据库
		#语言基础
		#面向对象
			抽象，封装，继承，多态
		#数据结构和算法
		    数据结构:
		    	HashMap,ArrayList,LinkedList的区别
		   		List，Map，Stack，Queue的区别
		    	Tree 二叉树  平衡二叉树
		    算法：
		    	排序
		    	查找 -二分查找
		#多线程和并发
				锁机制
				线程安全
				synchronized

				并发类：
				生产者和消费者
		#GC内存管理
				Java的内存模型
				GC，为什么要有GC?
		#IO流
				字符流和字节流
				输入流和输出流

				文件读写
				socket
				jdbc
		#异常处理 Error和Exception

		#网路编程
		#数据库
			数据库索引


		#Spring
			IOC/DI:
			AOP:
			事务管理:
			怎么整合其他服务（中间件）
		#SpringMVC的作用
			#
			#
		#ORM
			Mybatis
			Hibernate
		#高级特性: 注解 ，动态代理，反射，泛型

		#前端部分
			jquery-js
