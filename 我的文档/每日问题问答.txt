JAVA基础：


JAVA多线程和并发:

1.JAVA的锁机制?/JAVA怎实现线程安全?
 -2.什么是线程安全？为什么会有线程安全问题?   提出问题
 -3.怎么解决线程安全问题?                     解决问题
       -synchonrized 优点和缺点引出他的应用范围
       -Atomic       优点和缺点
       -Lock
       总结：你的建议应该如何选择
 -4.更细程度的说明锁机制的原理?
 -5.之前我们学习过的部分哪些东西有用到或者借鉴了这些机制？他们有什么异同？
 	数据库行级锁和表级锁
 	ConcurrentHashMap的锁分离
 	数据库事务
 	Servlet的请求：多线程（每一次请求都是一个线程有可能产生线程安全问题）
 -6.一些额外的注意点？


 回答：
 #什么是线程安全?
 	多个线程同时访问同一个资源(临界区)就有可能产生线程安全问题.
 #怎么解决线程安全问题?
 	一个程序一段代码是线程安全的需要满足一下三种特性:原子性，有序性和可见性
 	Java使用锁机制来解决线程安全问题，常见的有三种解决方式
 	1.synchonrized 是一种互斥锁，悲观锁和非公平锁;他有粗粒度(对整个方法加锁)和细粒度(对方法中的某一部分加锁)。保证了原子性和有序性
 	优点：最简单，JDK的内置模式，安全级别最高也是最先考虑的方式
 	缺点：性能最低，不恰当使用很容易产生死锁问题
 	2.Atomic原子变量 保证了原子性
 	优点：实现简单
 	缺点：他一般用于加减等数值操作的部分，局限性比较大
 	3.Lock 显示锁() 用法基本跟synchonrized一样，只是你可以自己定制锁的类别
 	优点：自己定制 需要你对锁机制的有比较深的理解。可以实现乐观锁和公平锁
 	缺点：自己定制 需要你对锁机制的有比较深的理解。

 	总结：优点使用synchonrized 当他无法满足我们的需求的时候再考虑其他的方式。注意死锁。
#锁机制的原理？
	互斥锁：资源只能被同一个线程访问
	悲观锁：资源不能被抢占
	乐观锁：可以通过一定的规则抢占资源
	公平锁：我们可以规定一些规则来决定资源的抢占。(计数器来做 每一次请求都会让你的请求计数+1，当达到指定数量后你就获得了资源的占有权)
	非公平锁：只要我请求资源，就一定是我的。
#之前我们学习过的部分哪些东西有用到或者借鉴了这些机制？他们有什么异同？
	数据库行级锁和表级锁
	ConcurrentHashMap的锁分离
	数据库事务
	Servlet的请求：多线程（每一次请求都是一个线程有可能产生线程安全问题）
	为什么String是final类型的(key值不可变)
#其他注意事项
	多线程产生死锁的四个必要条件： (前三个就是synchonrized的特点)
   	#互斥条件：一个资源每次只能被一个进程使用。
    #保持和请求条件：一个进程因请求资源而阻塞时，对已获得资源保持不放。
    #不可剥夺调教：进程已获得资源，在未使用完成前，不能被剥夺。
    #循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

  	只要破坏其中任意一个条件，就可以避免死锁，其中最简单的就是破环循环等待条件。按同一顺序访问对象，加载锁，释放锁。其中最简单的方法就是线程都是以同样的顺序加锁和释放锁，也就是破坏了第四个条件。

2.sleep和wait - wait和notify的区别
	这些都是线程的方法。wait释放锁，notify获得锁，sleep不会释放锁。

网络编程：

0.网络架构一共有几层?  OSGI模型
	1物理层
	2数字链路层
	#3网路层 - IP协议(标识你的计算机在网络中的位置，计算机通过IP地址找到另外一台计算机)
	#4传输层 - TCP协议(代表你有进行网络传输的功能)
	5会话层
	6表示层  - 加密解密 ，压缩和解压缩
	#7应用层 - (我们开发的WEB应用都是属于这一行) HTTP协议(你传输的是什么数据类型)

1.什么是TCP/IP协议?
	是协议簇(是一套协议的总结,TCP和IP协议最具有代表性)

	IP协议(标识你的计算机在网络中的位置，计算机通过IP地址找到另外一台计算机)
	TCP协议(代表你有进行网络传输的功能)
		面向连接(发数据之前要先确认连接的正确性)
		相当于打电话，需要先拨通再通话
	UDP协议(报文协议)
		面向无连接(发数据不需要任何准备，只管发)
		相当于短信，发出去之后无法知道对方到底有没有接收到。

	#TCP怎么保证连接的正确性
	TCP的三次握手：
		*  //什么是三次握手 syn包(请求包) ack包(确认包)
		*  //1.客户端向服务端发送请求syn包
		*  //2.服务端收到syn包，向客户端发送syn+ack包，服务端建立连接(可以接受数据了)
	 	*  //3.客户端收到syn+ack包,向服务端发送ack包， 客户端建立连接(可以接受数据了)

	#HTTP协议
	HTTP协议是TCP协议的一种，超文本传输协议。http是对TCP协议的扩展(本质上也是个TCP协议)
	TCP决定你可以进行传输,HTTP决定了你传输的数据类型
	为什么http协议很流行? 1.简单易用  2.很容易进行扩展 MIME（传输的文件类型编号，看tomcat的web.xml）

	请求只能由客户端发起，无法保持连接（下一次请求无法知道上一次请求的内容）
	keep-alive：HTTP1.1的内容，能保持一小段时间的连接(避免重复刷新等)

	请求头：
		Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8  （接收的文本类型）
		Accept-Encoding:gzip, deflate, sdch, br   （压缩算法）
		Accept-Language:zh-CN,zh;q=0.8,en;q=0.6,ja;q=0.4,zh-TW;q=0.2 （接收的语言）
		Cache-Control:no-cache   （缓存控制）
		Connection:keep-alive     （连接状态）
		Cookie:BAIDUID=6C2F642C3700496ED788B9E08154D874:FG=1; BIDUPSID=6C2F642C3700496ED788B9E08154D874; PSTM=1490253481; ispeed_lsm=2; BD_CK_SAM=1; PSINO=6; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; BD_HOME=0; H_PS_PSSID=22162_1459_21098_21671_22581; BD_UPN=12314353 （cookie编号）
		Host:www.baidu.com   （主机名称）
		Pragma:no-cache      （缓存控制）
		User-Agent:Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36  （浏览器类型）
	响应头：

	#HTTP和HTTPS有什么区别？  security安全
		公钥和秘钥，网络证书来保证连接的安全性
		HTTP是明文连接，连接可以被劫持()

2.什么是Socket?
	如果没有Socket，每次网络连接我都要处理七层的传输和协调。而且这些都是通用的方法
	所以我们就封装了一套API来统一处理 就是SOCKET。
	Socket是一套API，不是网络协议。来简化网络传输的编程。
	Socket是对网络各层的抽象，简化了网络传输的步骤。

JAVAEE三大框架

2.